#include <stdio.h>

#include "esp_log.h"
#include "esp_err.h"
#include "esp_check.h"

#include "freertos/FreeRTOS.h"
#include "freertos/event_groups.h"
#include "freertos/queue.h"

#include "mqtt_client.h"

#include "user_i2c.h"
#include "user_mqtt.h"


// -----------------------------------------
// Event groups definitions
#define MQTT_CONNECTED_BIT     BIT0
#define MQTT_DISCONNECTED_BIT  BIT1
#define MQTT_ERROR_BIT         BIT2

// ---------------------------------------------------------
// External variables
extern QueueHandle_t i2C_access_queue;
extern QueueHandle_t mqtt_tca_exchange_queue;

static EventGroupHandle_t       s_mqtt_event_group = NULL;
static esp_mqtt_client_handle_t mqtt_client  = NULL;


// ---------------------------------------------------------
// File scope variables
static const char* TAG = "MQTT";


// ------------------------------------------------------
// static (local) functions
static void log_error_if_nonzero(const char*, int);
static void mqtt_event_handler(void*, esp_event_base_t,int32_t, void*);
static void mqtt_pub_task(void* PvParameters);


// ------------------------------------------------------
// Log errors from TCP layer 
static void log_error_if_nonzero(const char *message, int error_code)
{
	if (error_code != 0) 
		ESP_LOGE(TAG, "Last error %s: 0x%x", message, error_code);
}



// ------------------------------------------------------
// Callback function for MQTT events
static void mqtt_event_handler(void* event_handler_arg,
            esp_event_base_t event_base,
            int32_t event_id, void* event_data)
{
    ESP_LOGI(TAG, "Message from Event loop base = %s, event_id = %"PRIi32"",
    event_base, event_id);
    
    // I2C device access control
    i2c_access_ctrl_handle_t i2c_access_handle;

    // Get data from event generated by MQTT event loop
    esp_mqtt_event_handle_t event = event_data;
    // Select actions according to event id
    switch ((esp_mqtt_event_id_t)event_id)
    {
    case MQTT_EVENT_ANY:
        ESP_LOGI(TAG, "MQTT_EVENT_ANY");
        break;
    case MQTT_EVENT_ERROR: // on error event
        if (event->error_handle->error_type == MQTT_ERROR_TYPE_TCP_TRANSPORT) 
        {
            log_error_if_nonzero("reported from esp-tls", event->error_handle->esp_tls_last_esp_err);
            log_error_if_nonzero("reported from tls stack", event->error_handle->esp_tls_stack_err);
            log_error_if_nonzero("captured as transport's socket errno",	event->error_handle->esp_transport_sock_errno);
            ESP_LOGE(TAG, "Last errno string (%s)", strerror(event->error_handle->esp_transport_sock_errno));
		}
        else 
            ESP_LOGE(TAG, "ERROR %s", strerror(event->error_handle->esp_transport_sock_errno));
        
        // Set event group bit, informing MQTT error
        xEventGroupClearBits(s_mqtt_event_group,MQTT_CONNECTED_BIT);
        xEventGroupSetBits(s_mqtt_event_group,MQTT_ERROR_BIT);
        break;
    case MQTT_EVENT_CONNECTED: // connected event
        ESP_LOGI(TAG, "MQTT_EVENT_CONNECTED");

        // Set event group bit, changing MQTT status to "Online"
        xEventGroupClearBits(s_mqtt_event_group,MQTT_DISCONNECTED_BIT);
        xEventGroupSetBits(s_mqtt_event_group,MQTT_CONNECTED_BIT);
        break;

    case MQTT_EVENT_DISCONNECTED: // disconnected event
        ESP_LOGI(TAG, "MQTT_EVENT_DISCONNECTED");

        // Set event group bit changing MQTT status to "Offline"
        xEventGroupClearBits(s_mqtt_event_group, MQTT_CONNECTED_BIT);
        xEventGroupSetBits(s_mqtt_event_group,MQTT_DISCONNECTED_BIT);
        break;
    case MQTT_EVENT_SUBSCRIBED: // subscribed event
        ESP_LOGI(TAG, "MQTT_EVENT_SUBSCRIBED");
   /* additional context:
    * - msg_id:         message id
    * - error_handle:   `error_type` in case subscribing failed
    * - data:           pointer to broker response, check for errors.
    * - data_len:       length of the data for this event
    */
        printf("broker response: %.*s\n", event->data_len, event->data);
        break;
    case MQTT_EVENT_UNSUBSCRIBED: // unsubscribed event
        ESP_LOGI(TAG, "MQTT_EVENT_UNSUBSCRIBED");
        break;
    case MQTT_EVENT_PUBLISHED: // published event
        ESP_LOGI(TAG, "MQTT_EVENT_PUBLISHED");
        break;
    case MQTT_EVENT_DATA: 
   /* additional context:
    * - msg_id:               message id
    * - topic:                pointer to the received topic
    * - topic_len:            length of the topic
    * - data:                 pointer to the received data
    * - data_len:             length of the data for this event
    * - current_data_offset:  offset of the current data for this event
    * - total_data_len:       total length of the data received
    * - retain:               retain flag of the message
    * - qos:                  QoS level of the message
    * - dup:                  dup flag of the message
    */
        ESP_LOGI(TAG, "MQTT_EVENT_DATA");
        // printf("topic: %.*s\n", event->topic_len, event->topic);
        // printf("message: %.*s\n", event->data_len, event->data);
        printf("QoS: %d\n", event->qos);

        // Memory allocation for topic
        char* topic = NULL;
        topic = malloc(event->topic_len+1);
        memset(topic,0,event->topic_len+1);
        memcpy(topic,event->topic,event->topic_len);

        // Memmory allocation for payload
        char* payload = NULL;
        payload = malloc(event->data_len+1);
        memset(payload,0,event->data_len+1);
        memcpy(payload,event->data,event->data_len);

        printf("Topic: %s\n",topic);
        printf("Payload: %s\n", payload);

        // Check the received topic
        if(strcmp(RELAY_OUTPUT_SET,topic) == 0)
        {
            i2c_access_handle.i2c_action   = MQTT_TCA_OUT_SET;
            i2c_access_handle.tca_out_stat = (uint16_t)strtol(payload,NULL,16);
            xQueueSend(i2C_access_queue,&i2c_access_handle,pdMS_TO_TICKS(50));

        }
        else if(strcmp(RELAY_INPUT_GET,topic) == 0)
        {
            i2c_access_handle.i2c_action   = MQTT_TCA_INP_GET;
            xQueueSend(i2C_access_queue,&i2c_access_handle,pdMS_TO_TICKS(50));
        }
        else if(strcmp(RELAY_OUTPUT_GET,topic) == 0)
        {
            i2c_access_handle.i2c_action   = MQTT_TCA_OUT_GET;
            xQueueSend(i2C_access_queue,&i2c_access_handle,pdMS_TO_TICKS(50));
        }


        // Handle the MQTT data event here (...)
        
        // Free usage memmory
        free(topic);
		free(payload);
        topic = NULL;
        payload = NULL;
        break;
    case MQTT_EVENT_BEFORE_CONNECT: // The event occurs before connecting
        ESP_LOGI(TAG, "MQTT_EVENT_BEFORE_CONNECT");
        break;
    case MQTT_EVENT_DELETED: // otification on delete of one message from the internal outbox
        ESP_LOGI(TAG, "MQTT_EVENT_DELETED");
        break;
    case MQTT_USER_EVENT: // Custom event used to queue tasks into mqtt event handler
        ESP_LOGI(TAG, "MQTT_USER_EVENT");
        break;
    default: // It was generated a non mapped event
        ESP_LOGW(TAG, "UNIDENTIFIED EVENT ID: %d", event->event_id);
        break;
    }  
    return;
}

// ------------------------------------------------------
// Configure and start MQTT protocol
esp_err_t user_mqtt_start(void)
{
    esp_err_t err = ESP_OK;
    // Create event group to hanlde MQTT connection status
    s_mqtt_event_group = xEventGroupCreate();

    esp_mqtt_client_config_t esp_mqtt_client_config = 
    {
        .network.disable_auto_reconnect = false, // enable autoreconnect
        .session.keepalive = 30, // keep alive for 30 seconds
        .broker.address.uri = ESP_BROKER_URL, // Broker URL
        .broker.address.port = ESP_BROKER_PORT, // Broker Port
        .session.last_will =  // Setup last will when node is disconnected
        {
            .topic = RELAY_STATUS,
            .msg = "offline",
            .msg_len = strlen("Offline"),
            .qos = 1
        }
    };
    // Create a new MQTT client handle
    mqtt_client = esp_mqtt_client_init(&esp_mqtt_client_config);

    // Register a callback function for MQTT events
    err = esp_mqtt_client_register_event(mqtt_client,ESP_EVENT_ANY_ID,
          mqtt_event_handler,NULL);
    if(err != ESP_OK)
        return err;
    
    // Start MQTT client
    err = esp_mqtt_client_start(mqtt_client);
    if(err != ESP_OK)
        return err;
    
    // Wait until MQTT conection is stabilished or return failure
    EventBits_t bits = xEventGroupWaitBits(s_mqtt_event_group, 
    MQTT_CONNECTED_BIT|MQTT_DISCONNECTED_BIT|MQTT_ERROR_BIT,pdFALSE,
    pdFALSE,portMAX_DELAY);

    if(bits&MQTT_CONNECTED_BIT)
    {
        mqtt_tca_exchange_queue = xQueueCreate(5,sizeof(mqtt_access_ctrl_handle_t));

        // Create an MQTT task for topics publication
        xTaskCreate(mqtt_pub_task,"MQTTPubTask",configMINIMAL_STACK_SIZE+2048,NULL,3,NULL);
        
        user_mqtt_publish(RELAY_STATUS,"online",1,true); // send status to subcripters

        // Topics subscription
        user_mqtt_subscribe(RELAY_OUTPUT_SET,1);
        user_mqtt_subscribe(RELAY_OUTPUT_GET,1);
        user_mqtt_subscribe(RELAY_INPUT_GET,1);

        ESP_LOGI(TAG,"Connected to Broker: %s",ESP_BROKER_URL);
        err = ESP_OK;
    }
    else if(bits&MQTT_DISCONNECTED_BIT)
    {
        ESP_LOGI(TAG,"Disconnected from Broker: %s",ESP_BROKER_URL);
        err = ESP_FAIL;
    }
    else if(bits&MQTT_ERROR_BIT)
    {
        ESP_LOGI(TAG,"Conection failure: %s",ESP_BROKER_URL);
        err = ESP_FAIL;
    }
       
    return err;
}

// ------------------------------------------------------
// Subscribe to a topic 
void user_mqtt_subscribe(char* topic, int qos)
{
    int msg_id = esp_mqtt_client_subscribe(mqtt_client,topic,qos);
    ESP_LOGI(TAG,"Sent subscribe successful, msg_id=%d",msg_id);

    return;
}

// ------------------------------------------------------
// Unsubscribe from a topic 
void user_mqtt_unsubscribe(char* topic)
{
    int msg_id = esp_mqtt_client_unsubscribe(mqtt_client,topic);
    ESP_LOGI(TAG,"Sent unsubscribe successful, msg_id=%d",msg_id);

    return;
}


// ------------------------------------------------------
// Publish a topic 
void user_mqtt_publish(char* topic, char* payload, int qos, bool retain)
{
    int msg_id = esp_mqtt_client_publish(mqtt_client,topic,payload,strlen(payload),
                 qos,(int)retain);
    ESP_LOGI(TAG,"Topic published successful, msg_id=%d",msg_id);
}


// ------------------------------------------------------
// Check for MQTT connection status
bool user_mqtt_con_status(void)
{
    EventBits_t bits = xEventGroupGetBits(s_mqtt_event_group);
    if(bits&MQTT_CONNECTED_BIT)
        return true;
    else 
        return false;
}

// ------------------------------------------------------
// Stop MQTT conection 
void user_mqtt_stop(void)
{
    esp_mqtt_client_stop(mqtt_client);
    ESP_LOGI(TAG,"MQTT stopped");
    return;
}


// ------------------------------------------------------
// Task for topics publications 
static void mqtt_pub_task(void* PvParameters)
{   
    char strbuff[10]; 
    mqtt_access_ctrl_handle_t topic;
    while(true)
    {
        xQueueReceive(mqtt_tca_exchange_queue,&topic,portMAX_DELAY);

        switch(topic.mqtt_action)
        {
            case MQTT_TCA_INP_PUB: // publish input status

                sprintf(strbuff,"%x",topic.tca_in_payload);
                printf("Publishing %s\n",strbuff);
                user_mqtt_publish(RELAY_INPUT_PUB,strbuff,1,false);

                break;
            case MQTT_TCA_OUT_PUB: // publish output status

                sprintf(strbuff,"%x",topic.tca_out_payload);
                printf("Publishing %s\n",strbuff);
                user_mqtt_publish(RELAY_OUTPUT_PUB,strbuff,1,false);

                break; 
            default:
        }
    }
}